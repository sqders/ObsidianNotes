# Определение
**`ArrayList`** реализует интерфейс **`List`** и представляет собой список значений. Его длина может изменяться - расширяться при необходимости, если кол-во элементов становиться больше, чем длина массива под капотом.
# Строение
В основе **`ArrayList`** лежит массив **`Object`**. Изначально его длина (**capacity**) = 10, а `size() = 0`.
**`ArrayList`** расширяет свою длину на 1.5, когда она заканчивается.
Как верно заметил [MikeMirzayanov](http://habrahabr.ru/users/mikemirzayanov/), при удалении элементов текущая величина capacity не уменьшается, что может привести к своеобразным утечкам памяти. Поэтому не стоит пренебрегать методом **trimToSize()**.
# Методы
1. `add()` - добавить элемент. **Можно указывать позицию первым аргументом.**
2. `get(int index)` - взять элемент с индексом `index`
3. `set(int index, T element)` - вставить элемент на нужную позицию
4. `size()` - кол-во элементов в листе
5. `remove(T element / int index)` - в 1 случае true/false, удачна ли операция, во 2 случае - элемент, который был удалён, если такого не нашлось возбуждается `IndexOutOfBoundsException`.
	!! **Удаление элемента подразумевает смещение большого числа элементов. Дорогая операция** !!
5. `contains()` - true/false, есть ли элемент в коллекции, исходя из метода `equals()`
6. `addAll(ArrayList aL / int index, ArrayList aL)` - добавляет все элементы другого ArrayList в конец. Или заменяет элементы текущего с необходимого индекса
7. `indexOf()` и `lastIndexOf()`- индекс элемента **или -1, если не найден**
8. `clear()` - очищает лист
9. `subList(int fromIndex, int toIndex)` - **создает "вид" на ArrayList**, который содержит элементы, с fromIndex до toIndex нашего ArrayList. Это лишь ссылка, изменение элементов в подлисте изменит элементы в исходном массиве. Если мы изменим исходный список, то наш "вид" станет невалидным и будет вызывать `ConcurrentException`
10. `removeAll(Collection<?> c)` - удаляет все элементы из коллекции, которые есть в ArrayList, а `retailAll(Collection<?> c)` - оставит только те элементы, что есть и в листе, и в коллекции. `containsAll()` - содержит ли ArrayList все элементы другой коллекции.
11. `toArray(T[] arr)` - конвертирует лист в массив нужного типа, который мы указываем в параметрах (Object[] по умолчанию). Если передаваемый массив больше, чем исходный список - недостающие элементы будут заполнены `null`. **Чтобы Java автоматически создала массив нужно длины под список - в параметр arr необходимо вставить новый массив длины 0.**
12. `List.of(E... elements)` - создает новый `List<E>` из переданный элементов, однако такой **список становится НЕИЗМЕНЯЕМЫМ и не может содержать значения null**
13. `List.copyOf(Collection<E> c)` - то же самое, что `List.of()`, **список становится НЕИЗМЕНЯЕМЫМ и не может содержать значения null**
### Итоги

  
— Быстрый доступ к элементам по индексу за время O(1);  
— Доступ к элементам по значению за линейное время O(n);  
— Медленный, когда вставляются и удаляются элементы из «середины» списка;  
— Позволяет хранить любые значения в том числе и null;  
— Не синхронизирован.
@see
[[Arrays - util class]], 