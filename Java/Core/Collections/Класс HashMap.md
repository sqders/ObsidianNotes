# Определение
**`HashMap`** - это класс, реализующий [[Интерфейс Map]] и под капотом использующий [[Хэш Таблицы]] для выполнения практически всех операций очень быстро.
![[Pasted image 20230608112302.png]]
# Особенности
1. Использует хеширование
2. Не запоминает порядок добавления элементов
3. Методы работают очень быстро благодаря хешированию, в среднем, за `O(1)`
4. В основе HashMap лежит массив (Массив класса Node). Элементы данного массива являются частями [[класс LinkedList|LinkedList]] и уже данные структуры заполняются элементами, которые мы добавляем в **HashMap**.
   ![[Pasted image 20230608113054.png]]
   **Класс Node содержит: ключ, значение, хэш ключа и ссылку на следующий элемент.** Относительно хэш-кода ключа, вычисляется место в массиве **table**, которое будет занимать элемент. Как только массив **table** достигает длины **loadFactor** (\% заполненных элементов становится > loadFactor\*100), он расширяется в 2 раза и перераспределяет все хеши по-новому, в новые ячейки. От **loadFactor** зависит экономия и расход памяти. Чем он больше, тем мы больше экономим ПАМЯТЬ, чем он меньше - экономим время выполнения, кол-во операций(сложность). Чаще всего **loadFactor = 0.75**
   ![[Pasted image 20230608113336.png]]
# Оптимизация и советы
## Оптимизация
**Это появилось с Java8**
После определенного порога элементов в LinkedList, вместо **LinkedList** в **HashMap** начинают использовать **СБАЛАНСИРОВАННЫЕ ДЕРЕВЬЯ** - справа всегда больший элемента, слева - меньший элемент

## Советы
1. В классе - ключе должны быть переопределены `equals()` и `hashcode()`
2. hashcode должен выполняться за `O(1)`
3. Ключами должны быть `Immutable objects` - неизменяемые объекты, чтобы hashcode объекта не изменялся.
# Методы
1. `put(K key, V value)` - вставляет значение по ключу
2. `putIfAbsent(K key, V value)` - добавляет элемент в коллекцию, если его там ещё нет, иначе - ничего не делает
3. `get(K key)` - берет значение по ключу
4. `remove(K key)` - удаляет запись по ключу
5. `containsValue(V value)` - если значение есть в Map - возвращает **true**
6. `containsKey(K key)` - если ключ есть в Map - **true**
7. `keySet() / values() / entrySet()` - возвращает множество ([[Интерфейс Set|Set]]) всех ключей / значений / сущностей, представляющих ключ и значение вместе.
# Итоги  
— Добавление элемента выполняется за время O(1), потому как новые элементы вставляются в начало цепочки;  
— Операции получения и удаления элемента могут выполняться за время O(1), если хэш-функция равномерно распределяет элементы и отсутствуют коллизии. Среднее же время работы будет Θ(1 + α), где α — коэффициент загрузки. В самом худшем случае, время выполнения может составить Θ(n) (все элементы в одной цепочке);  
— Ключи и значения могут быть любых типов, в том числе и null. Для хранения примитивных типов используются соответствующие классы-оберки;  
— Не синхронизирован.