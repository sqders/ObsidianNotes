# Определение
При обращении к файлу с целью прочитать - наша программа открывает **Channel**, который записывает инфу в **Buffer**, далее наша программа читает из **Buffer**. Когда хотим записать - пишем в **Buffer**, а потом **Channel** берет инфу из **Buffer** и пишет в файл.
![[Pasted image 20230610192854.png]]

![[Pasted image 20230610193112.png]]

# Отличия от io
Channel отличается от Streams тем, что Stream может читать/записывать только в 1 направлении и требует открытия другого потока для смены операции, а Channel поддерживает сразу и чтение и запись
# Пример
![[Pasted image 20230610194518.png]]
В примере выше мы создаем Канал(Channel) и буфер размерностью 25 байт. Мы читаем байты из файла в буфер(каналом) и проверяем, если количество прочитанных байт больше, чем 0, то можем читать из буфера, значит он не пуст. Сейчас **`position`** указывает на байт - последний элемент буфера, если он не смог поместить весь файл или последний номер байта, который был в файле. Чтобы читать с буфера, нам необходимо вызвать метод `flip()` - этот метод переключает режим буфера с записи на чтение и переводит наблюдаемый сейчас **`position`**(позиция текущего байта) на 0, т.е. в начало. После этого, пока в буфере ещё остались элементы, мы читаем их. Далее, чтобы снова писать - переключаем режим на запись методом `clear()` - этот метод очищает буфер и перемещает position на 0 элемент. Также, у нас есть указатель **`limit`** - Отражающий количество байт, которые были записаны в буфер. Примерная схема:
![[Pasted image 20230610195135.png]]
# Методы
![[Pasted image 20230611110118.png]]
1. `buffer.allocate()` - выделяет определенное кол-во байт под буфер
2. `buffer.clear()` - ставит position в 0 индекс и буфер готов к перезаписи своих значений
3. `buffer.flip()` - ставит position в 0 индекс и буфер готов к чтению своих данных каналом
4. `buffer.wrap()` - оборачивает информацию/ресурс в буфер, полностью помещая его туда. Нужно для лаконичной записи в файл, чтобы не передвигать указатель вручную
5. `buffer.rewind()` - помещает позицию на ячейку 0 в режиме чтения и это позволяет снова прочитать уже прочитанные элементы в буфере
6. `buffer.compact()` - копирует непрочитанные байты в буфере в его начало и передвигает position в конец этих непрочитанных байт, новая запись начинается оттуда
7. `buffer.mark()` и `buffer.reset()` - mark - ставит отметку на элементе буфера, чтобы потом с помощью `reset()` вернуться к этой метке (передвинуть **position** в `mark()`)