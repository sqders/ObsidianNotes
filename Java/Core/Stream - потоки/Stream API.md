# Определение
Потоки в java - это специальный API для удобного взаимодействия с коллекциями/данными. Объекты определенных классов могут быть преобразованы в потоки и с потоками существует огромное количество всевозможных операций, которые очень удобно использовать с [[Lambda - выражения|lambda - выражениями]]. Stream никак не влияет и не изменяет коллекцию, к которой применяется и **может быть использован только 1 раз**
# Использование
Используется либо на самом объекте - структуре данных:

Или через обобщающий класс, например, как с массивами, через **`Arrays`**
# Метод chaining
Method chaining - это возможность применять цепочку вызовов следующим образом:
![[Pasted image 20230609133801.png]]
![[Pasted image 20230609133730.png]]
**ВАЖНО - все терминальные методы, которые обрабатывают последовательность, но не возвращать результат являются lazy.**
Это означает, что они не запускаются до тех пор, пока не будет запущен терминальный метод, который возвратит куда-то элементы.
# Самые встречающиеся и нужные методы
1. `.stream()` - преобразовывает структуру данных в поток
2. `map()` - создает отображение данных на основе заданного лямбда-выражения. Т.е. преобразовываем элемент из старого множества в элемент нового множества и возвращаем новое множество
3. `collect()` - преобразовывает поток в структуру данных (обратно) с помощью **`Collectors`**.
   Использование: `***.map(x -> x \* 2).collect(Collectors.toList());`
   Также есть: `Collectors.groupingBy()` (группировка по) - возвращает Map, группирует элементы по какому-то полю/свойству, а в значение помещается список из элементов, которые имеют поле идентичное ключу.
   `Collectors.partitioningBy()` (разделение по) - разделяет поток на 2 части - принимает **Predicate**. Результат - Map с ключом `boolean` и значением - списком элементов, которые соответствуют/не соответствуют **Predicate**.
4. `toArray()` - преобразовывает поток в массив.
5. `filter()` - выделяет подмножество из данных, которое соответствует условию в лямбда-выражении
6. `forEach()` - проходится по всем элементам коллекции
7. `reduce()` - "сжимает" набор данных в 1 **Optional** элемент. Например, посчитать сумму всех элементов, какой-то параметр, среднее и т.п.
   Принимает 2 аргумента:
   1. Аккумулятор - **identity**. **По умолчанию равняется первому элементу в массиве и итерация начинается с индекса 1**, чтобы изменить, перед лямбдой надо написать начальное значение
   2. Текущий элемент - **op**
  `isPresent()` у **Optional** - проверяет, есть ли в текущем потоке вообще элемент или нет. Используется перед методом `get()` Optional типа, чтобы не поместить null в примитивный тип.
  8. `sorted()` - сортирует поток по компаратору. Требует реализации у элементов интерфейса **Comparable** или указания явного **Comparator**(see [[Comparable и Comparator]])
  9. `distinct()` - выбирает уникальные элемент по методу `equals()`
  10. `Stream.concat()` - объединяет 2 потока
  11. `peek(Consumer c)` - может быть применен на различных этапах method chaining, часто используется для отладки
  12. `flatMap()` - для работы с элементами коллекции, которые являются элементами другой коллекции
      ![[Pasted image 20230610093001.png]]
  13. `mapToInt()` -  после исполнения возвращает **IntStream**. Однако, чтобы конвертировать **IntStream** в коллекцию с типом **Integer**, необходимо привести **IntStream** к `Stream<Integer>`, сделать это можно с помощью метода `boxed()` - он просто переводит **int** в **Integer**.![[Pasted image 20230610094330.png]]
# Простые примеры
1. `reduce()`
   ![[Pasted image 20230607132409.png]]
   `reduce()` возвращает `Optional` тип, у него уже вызываем метод `get()`.
   