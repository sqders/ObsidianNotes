# Определение
Semaphore - класс для ограничения доступа к ресурсу, который использует большое кол-во потоков.
# Идея
## Решаемая семафором задача
Как сделать так, чтобы "поезда" не столкнулись на ж/д переезде, соединяющим 2 пути?
![[Pasted image 20230629102635.png]]
## Решение
Поставить **семафор** на точку соприкосновения путей. **Если семафор открыт - проезд разрешен, если закрыт - запрещен.** ***НО*** *чтобы проехать - сначала необходимо ЗАКРЫТЬ семафор, а только потом проехать* 
# Зачем необходим?
Это класс, который используется при использовании ресурса большим количеством потоков. **Он обеспечивает ограничение доступа к ресурсу**, **но не обеспечивает ОЧЕРЕДНОСТЬ** этого доступа. Семафор может быть открыт в любой момент и если наш поток его "проморгает" - семафор пропустит другой поток.

**В конструкторе передается число**, которое обозначает количество разрешений (**permits**) для потоков. Например, сколько потоков одновременно могут отправлять данные на сервер и в зависимости от пропускной способности канала, мы ограничиваем кол-во потоков. Чтобы поток смог начать работу - он получает разрешение методом `acquire()` и когда он заканчивает работу, он отдает разрешение обратно методом `release()`, позволяя заменить себя.

## Методы
1) **`release()`** - отпускает одно из разрешений. Вызываем, когда в потоке мы заканчиваем использовать ресурс. **ОБЯЗАТЕЛЬНОЕ УСЛОВИЕ** - метод `release()` должен вызываться всегда в **finally** блоке кода, чтобы вызванное исключение в методе не пропустило метод `release()`
2) **`acquire()`** - забирает разрешение у семафора. Если сейчас количество разрешений равно нулю, то **останавливает поток и ожидает освобождения места на ресурс**.
3) **`availablePermits()`** - возвращает количество доступных разрешений.
## Использование
Когда мы имеем ценный ресурс, к которому хотим ограничить доступ, мы используем **`Semaphore`** и когда какой-то поток начинает взаимодействие с ресурсом - вызываем метод `acquire()`, когда заканчивает - `release()`.
# Пример
![[Pasted image 20230604120825.png]]
В данном примере у нас есть `Connection` класс, реализующий паттерн **Singleton**, соединение представляет ценный ресурс и может быть перегружено, если с ним работает больше 20 потоков. Чтобы дать ограничение, мы используем класс **`Semaphore`** и запрещаем более чем 10 потокам одновременно работать с `Connection`. Делаем мы это, оборачивая метод, где идет работа с соединением ещё одним публичным методом и приватный оборачиваем в **`Semaphore.acquire()`** и **`Semaphore.release()`**, тем самым ограничивая доступ к работе метода `doWork()` только 10-ю потоками.

Зачем мы обернули метод `doWork()`? Для того, чтобы метод `release()` был в `finally` блоке, т.к. в методе `doWork()` может возникнуть исключение и до `release()` может не дойти. А таким образом, обеспечивается 100% выполнение метода `release()`
#Многопоточность #потокобезопасный #синхронизацияПотоков 