# Определение
Данное ключевое слово используется для определения очереди и блокирования ресурса в момент, когда в нём идет запись, а также его своевременного обновления для других потоков.
# Что фиксит
Фиксит ситуацию, когда несколько потоков **ПИШУТ** в одну переменную/ресурс и происходит [[Состояние гонки|состояние гонки]]. Ключевое слово синхронизует работу 2х или более потоков при записи.
# Как работает
Ключевое слово **`synchronized`** работает таким образом, что только 1 поток в единицу времени получает доступ к методу/блоку **`synchronized`**. Остальные потоки выстраиваются в очередь и блокируются в выполнении, ожидая освобождения ресурса потоком, который сейчас его использует.

**Синхронизация в статических методах** реализуется с помощью монитора по текущему классу / статическому объекту. Часто применяют конструкцию `synchronized(Data.class)`, чтобы не создавать лишний объект. **Так чище.**
### Внутренняя работа
#### Для синхронизации нужен объект
Для синхронизации нужен **объект**, т.к. она построена именно на объектах. При создании объекта, создается его единственный **Monitor lock**  - это сущность, с помощью которой можно обращаться к объекту, вызывать его методы и т.д, она присваевается единожды каждому созданному объекту и **эта сущность в 1 момент времени может быть только у 1 потока**. И **`synchronized`** использует именно эту особенность Java. Monitor в Java необходим, чтобы поток мог получить доступ к полям/методам объекта. Если мы не синхронизируемся на объекте явно (**`synchronized`** в сигнатуре метода), то синхронизация происходит по ключевому слову **`this`**, т.е. объектом является объект, владеющий методом.
# Где и как использовать
Используется в сигнатуре **методов** или отдельными **блоками**
# Пример:
![[Pasted image 20230603155052.png]]
В данном примере, без synchronized, наши потоки, используя не [[Атомарность операций|атомарную]] операцию инкремента, могут дать результат не 200000, а меньше, т.к. могут отдать управление до того, как присвоили `counter` новое значение + 1. Слово synchronized привязано к объекту `this` - т.е. к `object`, метод которого передается двум потокам.
# Плохой пример использования
![[Pasted image 20230603161200.png]]
Здесь если не использовать synchronized возникает ситуация гонки - 2 потока гонятся, чтобы заполнить листы 1 и 2. Но мы хотели бы синхронизировать их работу. С 2-мя листами ведут работу 2 разных метода. Пробуем повесить на них synchronized - всё работает, однако в 2 раза дольше! Это происходит потому, что synchronized в сигнатуре метода указывает на текущий объект, а значит, один поток ждёт, пока другой освободит целый объект - он не может обратиться к метода addToList2, пока работает addToList1 или addToList2 в другом потоке. Эту ситуацию исправляет грамотная работа с ресурсами. Обычно это делают через отдельные объекты - Локи (locks). Пример оптимизации этой программы приведен ниже:
![[Pasted image 20230603161646.png]]
![[Pasted image 20230603161705.png]]