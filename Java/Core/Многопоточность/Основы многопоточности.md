Как таки не странно, многопоточность не ускоряет работу программ. Ускоряет работу программ - **распараллеливание**. А для неё нужна мощная аппаратная часть. Использование многопоточности только визуально ускоряет работу клиента, не сервера.
# Зачем
**Многопоточность** создана для того, чтобы **одна программа могла одновременно решать ряд разных задач**.
А вот **распараллеливание** (реальное ускорение работы программы) используется, когда нам необходимо **ускорить решение одной задачи**
Раньше задачу многопоточности можно было решать **таймером и событиями**.
**Пример:** у нас есть графический интерфейс для воспроизведения видео - когда мы нажимаем Play - оконный интерфейс становится не доступным, т.к. мы начинаем перебирать массив кадров из файла - воспроизводить видео. Чтобы оставить пользователю возможность взаимодействовать с оконным интерфейсом, необходимо выполнять перебор кадров по таймеру. Каждый тик - обновляет новый кадр и таким образом, можно взаимодействовать с оконным интерфейсом. Однако, таймеры достаточно медленные и дают большую нагрузку на компьютер (обычно для игр ставят таймеры 7-10мс).
Ещё **пример**, но уже использования **многопоточности**: имеем сервер и клиентов. Цель сервера - обработать запросы и отдать ответ клиентам. На обработку клиента уходит время и если сервер однопоточный - придется выстраивать клиентов в очередь, а такая очередь может быть очень долгой, это неприемлемо. Решение - обрабатывать клиентов в отдельном потоке (однако, такая схема не применима в реальности, необходимо ограничивать количество потоков, а не создавать новый для каждого клиента). Однако, при таком подходе, **клиенты будут получать ответ быстрее? Да**. **НО!** Сам ответ **сервером будет отдаваться медленнее**, т.к. нагрузка на сервер возрастёт.
# Класс [[Thread]]