# Определение
Generic классы/методы - это классы/методы, которые принимают в качестве аргументов или возвращаемого значения неопределенные типы. Чаще всего называется `T` (из C++ Template), `E` - если работаем с элементами, `K` - если работа с ключами, `V` - работа со значениями. Эти буквы называются **Type Placeholder** - хранитель типа. **Переменные параметризованного типа не могут быть статическими.**
# Зачем?
Самая основная цель - **Type Safe** - это перенести ошибки выполнения на этап компиляции. Помещая объекты, допустим, в контейнер обобщенного типа, мы можем допустить некоторые ошибки при которых runtime будет сломан. Generics предотвращают подобное и не допускают помещение объектов разных типов в контейнеры/параметры и т.п.
Также, Generics делают код более - **Reusable** - лаконичным, красивым и надёжным. Предотвращают дублирование кода.
# Parametrized Class
![[Pasted image 20230608093240.png]]
# Parametrized Method
![[Pasted image 20230608093708.png]]
# Уточнения (Subtyping) Generics
1. `<?>` - любой класс - так называемый **WildCard**. Применяется для максимальных обобщений, операций, для которых вообще не важен тип элемента. **Пример:**
   ![[Pasted image 20230608101755.png]]
   Без `<?>` мы можем передать только конкретный класс в `List<>` и даже `List<Object>` работать не будет, ибо он может принять **только объекты типа `Object`(контрвариантность)**. Но можно использовать **Bounded Wildcards** - с уточнениями типов:
   ![[Pasted image 20230608102210.png]]
   ![[Pasted image 20230608102419.png]]
1. `<? extends X>` - класс X или любой его **subClass** (потомок)
2. `<? super Y>` - класс Y или любой его **superClass** (родитель)
Имплементирование интерфейса можно также вписать в блок extends следующим образом с помощью **&**:
![[Pasted image 20230608100911.png]]
# JVM
JVM не воспринимает Generics и просто преобразовывает всё кастами - вручную, однако, такие касты гарантировано безопасны. Также JVM создает промежуточные "мостовые" методы, чтобы перегонять одни типы данных в другие. Если **Type PlaceHolder** extends SomeClass, то в JVM все объекты / вызовы будут не Object, а SomeClass, т.к. он как раз становится самым основным родителем, в Object нет необходимости. Это механизм **Type Erasure** (**Стирание типов**) - информацию о Generic-типах знает только компилятор, а JVM нет.
# Ограничения
**Стирание типов** не позволяет делать такие конструкции (методы с одинаковыми сигнатурами, но разными входными параметрами):
   ![[Pasted image 20230608101314.png]]
   **Overriding:**
   ![[Pasted image 20230608101430.png]]
   **WildCards - нельзя изменять объект:**
   ![[Pasted image 20230608102018.png]]