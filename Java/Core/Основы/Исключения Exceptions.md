## Для чего?
Обработка неожиданных ситуаций, ошибок внешнего (не внутреннего)
## Генерирование исключений
Осуществлятеся с помощью ключевого слова `throw`. Когда выполняет этот оператор, нормальный порядок исполнения кода немедленно прерывается, управление передается [[обработчику исключений]]
### Иерархия исключений
![[Pasted image 20230514081903.png]]
**Непроверяемые исключения** представлены производными классами от `RuntimeException`. Они не обрабатываются программно, при их возникновении можно только уведомить пользователя о непоправимой ошибке. ***Непроверяемое исключение - это ошибка логики программиста, а не юзера***
**Проверяемые исключения** - это все остальные исключения, они производные от класса Exception. *Все подобные исключения должны быть объявлены в заголовке метода с оператором `throws`.* При переопределении методов, исключения берутся из суперкласса, их количество не может быть увеличено.
## Перехват исключений
Осуществляется с помощью блока `try/catch`
```
try {
	операторы
} catch (КлассИсключения ex) {
	обработчик
} 
```
Чтобы обработать разные исключения в 1 catch блоке, используй:  `catch (Class1 | Class2 | Class3)`
### Оператор try с ресурсами
Допустим, мы пишем текст в файл. И при записи в цикле, возникает ошибка, которая прерывает поток исполнения дальше. После цикла стоит `.close()` метод для закрытия потока файла. До этой инструкции при исключении не дойдёт поток исполнения и файл будет открыт, что может пагубно отразиться на производительности и исчерпать количество дескрипторов файлов. Для того, чтобы избежать этого, существует интерфейс `AutoCloseable` и особая форма `try`:
```java
try (ТипРесурса1 res1 = init1; ТипРесурса2 res2 = init2; ...) {
	операторы
}
Пример:
ArrayList<String> lines = ...;
try (PrintWriter out = new PrintWriter("output.txt")) {
	for (String line : lines) {
		out.println(line.toLowerCase());
	}
}
```
Ресурсы закрываются в обратном порядке их инициализации. Например, в коде ниже `out.close()` первый, `in.close()` второй:
```java
try (Scanner in = new Scanner(Paths.get("/usr/share/dict/words"));
		PrintWriter out = new PrintWriter("output.txt")) {
	while (in.hasNext())
		out.printIn(in.next().toLowerCase());
}
```
### Оператор finally
Иногда, требуется не только закрыть ресурс, но и очистить его или совершить какие-либо действия не зависимо от того, произошло исключение или нет. Тогда необходимо использовать оператор `finally` - это конструкция `try(с ресурсами)/finally` или `try(обычный)/catch/finally`. По такому образцу следует действовать всякий раз, когда требуется **установить и снять блокировку, инкрементировать и декрементировать счетчик или разместить данные в стеке и затем извлечь их из стека по завершении основной операции**.
### Повторное генерирование исключений и связывание исключений в цепочку
Если возникает исключение, которое нужно залогировать, но обработчик стоит отдельно, необходимо повторно вызвать исключение после логирования:
```
try {
Выполнить действия
} catch (Exception ex) {
	logger.log(level, message, ex);
	throw ex;
}
```
Чтобы создать цепочку исключений, можно создать новое исключение в `catch` и инициатором его выбрасывания, определить перехваченное исключение. Например:
```
try {
Доступ к базе данных
} catch (SQULexception ex) {
	Throwable ex2 = new CruftyOldException("database error");
	ex2.initCause(ex);
	throw ex2;
}
```
**Tip:** Механизм связывания исключений в цепочку оказывается удобным в том случае, если проверяемое исключение происходит в методе, где запрещено генерировать проверяемое исключение. Такое исключение можно перехватить и связать его в цепочку с непроверяемым исключением.
### Ловля завернутых исключений
Чтобы обнаружить завернутую ошибку требуется использовать метод Exception.getCause() и выбросить эту ошибку через throw
```java
SomeCheckedExceptions sce = new SomeCheckedExceptions();  
sce.throwSomeUncheckedExceptions(3);  
for(int i = 0; i < 4 ;i++){  
    try{  
        if(i<3){  
            sce.throwSomeUncheckedExceptions(i);  
        }else throw new SomeException();  
    } catch(SomeException e){  
        System.out.println("SomeException "+e);  
    }catch(RuntimeException re){  
        try{  
            throw re.getCause();  
        }catch (FileNotFoundException e){  
            System.out.println("FileNotFoundException "+e);  
        }catch (IOException e){  
            System.out.println("IOException"+e);  
        }catch (Throwable e){  
            System.out.println("Throwable"+e);  
        }  
    }
```
### Трассировка стека
Это перечень всех зависших вызовов методов на момент генерирования исключения. Результат направляется в стандартный поток вывода ошибок `System.err`
Если требуется сохранить в другом месте - нужно установить **обработчик необрабатываемых исключений**:
```
Thread.setDefaultUncaughtExceptionHandler((thread, ex) -> {
	Зарегистрировать исключение
});
```
### Objects.requireNonNull()
Это метод из класса Object, который очень удобен для проверки параметров на пустые значения.
```
public void process(String directions) {
	this.directions = Objects.requireNonNull(directions);
}
```
