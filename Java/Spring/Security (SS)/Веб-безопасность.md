Spring Security на веб-уровне (для пользовательских интерфейсов и серверных частей HTTP) основана на Servlet `Filters`, поэтому полезно сначала взглянуть на роль `Filters` в целом. На следующем рисунке показано типичное распределение обработчиков для одного HTTP-запроса:
![[Pasted image 20230828131020.png]]
Клиент отправляет запрос приложению, и контейнер решает, какие фильтры и какой сервлет применить к нему, на основе пути URI запроса. 
- **Максимум один сервлет может обработать один запрос**, но фильтры образуют цепочку, поэтому они упорядочены. 
- Фактически, **фильтр может наложить вето на остальную часть цепочки,** если он хочет обработать запрос сам. 
- Фильтр также может изменять запрос или ответ, используемые в нижестоящих фильтрах и сервлете. 
**Порядок цепочки фильтров очень важен**, и Spring Boot управляет им с помощью двух механизмов: у `@Beans` типа `Filter` может быть `@Order` или реализация интерфейса `Ordered`, и они могут быть частью `FilterRegistrationBean`, который сам имеет порядок как часть своего API. Некоторые готовые фильтры определяют свои собственные константы, чтобы помочь определить, в каком порядке они хотели бы располагаться относительно друг друга (например, у `SessionRepositoryFilter` из весенней сессии есть `DEFAULT_ORDER = Integer.MIN_VALUE + 50`, что говорит нам о том, что ему нравится быть в начале цепочки, но это не исключает, что другие фильтры будут предшествовать ему).

Spring Security устанавливается как единое `Filter` звено в цепочке, и по причинам, о которых мы скоро расскажем, ее конкретным типом является `FilterChainProxy`. 
В приложении Spring Boot **фильтр безопасности является `@Bean` в `ApplicationContext`**, и он установлен по умолчанию, так что применяется к каждому запросу. 

(Он устанавливается в позицию, определенную `SecurityProperties.DEFAULT_FILTER_ORDER`, которая, в свою очередь, привязана к `FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER` (максимальный порядок, который приложение Spring Boot ожидает от фильтров, если они завершают запрос, изменяя его поведение) )

Однако это нечто большее: с точки зрения контейнера Spring Security представляет собой единый фильтр, но внутри него есть дополнительные фильтры, каждый из которых играет особую роль. На следующем рисунке показана эта взаимосвязь:
![[Pasted image 20230828132750.png]]
Фактически, в фильтре безопасности есть еще один уровень косвенности: обычно он устанавливается в контейнере как `DelegatingFilterProxy`. Прокси этот прокси делегирует [`FilterChainProxy`](obsidian://open?vault=Java&file=Java%2FSpring%2F%D0%90%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8%2FSecurity%20(SS)%2FFilterChainProxy), который всегда является a `@Bean`, обычно с фиксированным именем `springSecurityFilterChain`.

Ванильное приложение Spring Boot без пользовательской конфигурации безопасности имеет несколько (назовем это n)[цепочек фильтров](obsidian://open?vault=Java&file=Java%2FSpring%2F%D0%90%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8%2FSecurity%20(SS)%2F%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0%20%D1%86%D0%B5%D0%BF%D0%BE%D1%87%D0%B5%D0%BA%20%D1%84%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D0%BE%D0%B2), где обычно n = 6. Первые цепочки (n-1) предназначены только для игнорирования шаблонов статических ресурсов, таких как `/css/**` и `/images/**`, и представления ошибок: `/error`. (Пользователь может управлять путями с помощью `security.ignored` из `SecurityProperties` компонента конфигурации.) Последняя цепочка соответствует всеобъемлющему пути (`/**`) и является более активной, содержащей логику для аутентификации, авторизации, обработки исключений, обработки сеанса, написания заголовка и так далее. По умолчанию в этой цепочке всего 11 фильтров, но обычно пользователям нет необходимости беспокоиться о том, какие фильтры используются и когда.

Создание [своих цепочек фильтров](obsidian://open?vault=Java&file=Java%2FSpring%2F%D0%90%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8%2FSecurity%20(SS)%2F%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0%20%D1%86%D0%B5%D0%BF%D0%BE%D1%87%D0%B5%D0%BA%20%D1%84%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D0%BE%D0%B2)это обычное дело!

Spring Security на веб-уровне в настоящее время привязана к Servlet API, поэтому она действительно применима только при запуске приложения в контейнере servlet, встроенном или ином. Однако он не привязан к Spring MVC или остальной части веб-стека Spring, поэтому его можно использовать в любом приложении—сервлете - например, использующем JAX-RS.