Существуют следующие *способы включить бин в контекст* (далее мы рассмотрим их подробнее):
- [посредством аннотации @Bean;] 
- [посредством стереотипных аннотаций];
- [программно]
После того как зависимость будет добавлена в проект, можно создать экземпляр контекста Spring. В листинге 2.6 показано, что нужно изменить в методе main, чтобы создать экземпляр контекста Spring.
![[Pasted image 20230910173231.png]]
![[Pasted image 20230910173458.png]]
## Посредством аннотации @Bean

**Класс конфигурации** позволяет, в частности, **добавлять бины в контекст Spring**. Для этого нужно определить **метод**, возвращающий экземпляр объекта, который мы хотим добавить в контекст, и снабдить этот метод **аннотацией @Bean**. Она сообщит Spring о том, что при инициализации контекста нужно **вызвать данный метод и добавить возвращенное им значение в контекст**.

![[Pasted image 20230910203732.png]]
`Как вы, вероятно, знаете, хорошим тоном программирования на Java является использование имен в форме глагола, так как методы обычно описывают некие действия. Однако для методов, добавляющих бины в контекст Spring, мы сделаем исключение. Эти методы описывают экземпляры возвращаемых ими объектов, которые затем становятся частью контекста Spring. Имя метода становится именем бина (например, в листинге 2.8 бин получает имя parrot).`

Итак, мы создали класс конфигурации, где сообщили Spring о существовании экземпляра объекта, который должен стать бином. Теперь нужно сделать так, чтобы Spring использовал этот класс конфигурации при инициализации контекста.
![[Pasted image 20230910204112.png]]

	Напомнюо назначении контекста Spring:мы добавляемтуда те экземпляры, которыми Spring должен управлять. (Таким образом подключая к ним функционал фреймворка.) В реальных приложениях далеко не все объекты включаются в контекст Spring


Итак, мы научились добавлять в контекст Spring один или несколько бинов разных типов. Но можно ли включить туда **несколько объектов одного типа**? И если можно, то как различать эти объекты?
Можно объявить **любое количество экземпляров одного типа, просто декларируя для каждого свой метод с аннотацией @Bean**.
```java
@Configuration
public class ProjectConfig {
 @Bean
 Parrot parrot1() {
 var p = new Parrot();
 p.setName("Koko");
 return p;
 }
 @Bean
 Parrot parrot2() {
 var p = new Parrot();
 p.setName("Miki");
 return p;
 }
 @Bean
 Parrot parrot3() {
 var p = new Parrot();
 p.setName("Riki");
 return p;
 }
}
```
Понятно, что теперь мы не сможем получать бины из контекста, указав один лишь их тип. Если попробовать так сделать, то получим исключение, поскольку Spring не сможет угадать, на какой именно из объявленных экземпляров вы ссылаетесь.
Чтобы устранить эту неоднозначность, необходимо точно сослаться на один из экземпляров по имени его бина
![[Pasted image 20230910204814.png]]
Если вы захотите присвоить бину другое имя, то можете указать его в аннотации @Bean в качестве атрибута name или value.
![[Pasted image 20230910204836.png]]

---
#### ОПРЕДЕЛЕНИЕ БИНА В КАЧЕСТВЕ ПЕРВИЧНОГО
Как уже говорилось ранее, в контексте Spring можно использовать несколько
бинов одного типа, но при этом на них необходимо ссылаться по именам.
Есть и другой способ сослаться на бин в подобном случае.
При наличии в контексте Spring нескольких бинов одного типа один из бинов можно сделать первичным. Для этого используется аннотация [@Primary].
Spring применяет первичный бин тогда, когда существует несколько бинов
данного типа и конкретное имя не указано. По сути, первичный бин — это
просто бин, который Spring использует по умолчанию. В следующем примере
показано, как выглядит метод для бина, выбранного в качестве первичного:
```java
@Bean
@Primary
Parrot parrot2() {
 var p = new Parrot();
 p.setName("Miki");
 return p;
}
```
---
## C помощью стереотипных аннотаций
Стереотипные аннотации размещаются над классом, экземпляр которого мы хотим добавить в контекст Spring. Таким образом мы сообщаем Spring, что данный класс является **компонентом**. Когда приложение создает **контекст Spring**, фреймворк, в свою очередь, **создает экземпляр класса, отмеченного как компонент**, и добавляет этот экземпляр в свой контекст.
Чтобы добавить стереотипную аннотацию, нужно сделать следующее:
1. Отметить аннотацией `@Component` те классы, экземпляры которых вы хотите
поместить в контекст Spring (в нашем случае это класс Parrot).
2. Используя аннотацию `@ComponentScan` в классе конфигурации, сообщить
Spring, где находятся классы, отмеченные аннотацией `@Component`
![[Pasted image 20230910205745.png]]
Чтобы Spring искал классы со стереотипными аннотациями, нужно воспользоваться аннотацией @ComponentScan в классе конфигурации проекта.
![[Pasted image 20230910205833.png]]
Теперь мы сообщили Spring следующее.
1. Экземпляры каких классов нужно добавить в контекст (Parrot).
2. Где находятся эти классы (с помощью аннотации @ComponentScan)

Используя Spring в реальных приложениях, вы скоро заметите, что применяете **стереотипные аннотации везде**, где только можно (ведь они требуют меньше кода), а `@Bean` — лишь когда нет других вариантов (например, когда вы создаете бин для класса, являющегося частью библиотеки, и не можете изменить этот класс, чтобы добавить в него стереотипную аннотацию).
![[Pasted image 20230910210044.png]]

## Программное добавление 
Такой подход позволило включать в контекст **новые экземпляры** непосредственно, вызывая **метод экземпляра контекста**. Данный способ используется в тех случаях, когда нужно реализовать нестандартное добавление бинов в контекст и возможностей @Bean и стереотипных аннотаций для этого недостаточно. Предположим, нам **нужно зарегистрировать в контексте Spring те или иные бины, в зависимости от специфической конфигурации приложения**.

Посмотрим, как работает этот метод. 
**Чтобы программно добавить бин в контекст Spring, достаточно просто вызвать метод registerBean() экземпляра ApplicationContext**. Как показано в следующем фрагменте кода, метод registerBean() принимает четыре параметра.
```java
<T> void registerBean(
 String beanName,
 Class<T> beanClass,
 Supplier<T> supplier,
 BeanDefinitionCustomizer... customizers);
```


1. Первый параметр, beanName, — это **имя бина**, добавляемого в контекст Spring. Если вы не хотите присвоить имя бину, который включается в контекст, при вызове метода присвойте этому параметру значение null.
2. Второй параметр — **класс, который определяет бин**, добавляемый в контекст. Если вы хотите добавить экземпляр класса Parrot, то значением этого параметра будет Parrot.class.
3. Третий параметр — это экземпляр Supplier. Реализация Supplier нужна, чтобы возвращать значение экземпляра, добавляемого в контекст. Напомню: Supplier — это функциональный интерфейс, который входит в пакет Java.util.function. Назначение реализации Supplier состоит в том, чтобы возвращать заданное значение, не принимая параметров.
4. Четвертый, и последний, параметр — это аргумент переменной длины (varargs) BeanDefinitionCustomizer. (Если вы впервые слышите это слово, ничего страшного: BeanDefinitionCustomizer — просто еще один интерфейс, **который используется для настройки различных свойств бина, например, чтобы сделать бин первичным**.) Определив его как аргумент переменной длины, мы можем либо совсем пропустить этот параметр, либо присвоить ему несколько значений типа BeanDefinitionCustomizer.
![[Pasted image 20230910231105.png]]
![[Pasted image 20230910231116.png]]
