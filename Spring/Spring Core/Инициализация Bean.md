Смотря на жизненный цикл Bean:
![[Pasted image 20231123145404.png]]

![[Pasted image 20231123145328.png]]
Можно заметить что сначала Spring внедряет компоненты, после чего обрабатываются пользовательские методы инициализации компонента, в порядке:

**аннотация** @PostConstruct -> реализация **интерфейса** InitializingBean -> **init метод** конфигурации компонента 
#### В той же последовательности происходит уничтожение компонента
![[Pasted image 20231123145904.png]]
**Аннотация** @PreDestroy -> **реализация интерфейса** DisposableBean -> **destroy() метод** конфигурации компонента
#### Каким может быть init() метод
 Можно определить любой возвращаемый тип, хотя он **игнорируется** Spring, и даже восполь­зоваться статическим методом, но этот метод **не должен принимать аргументы**. 
 
 Если применяется статический метод инициализации, то преимущества данного механизма сводятся на нет, поскольку нельзя получить доступ к состоянию любого компонента Spring Bean для его проверки.
 
 Он может понадобится для проверки статического состояния.
### Аннотация @PostConstruct
Как только появятся компоненты Spring Beans с внедренными зависимостями, делается запрос компонентов типа **BeanPostProcessor** из инфраструктуры предварительной инициализации, чтобы выяснить, требуется ли им вызвать  что-нибудь из данного компонента Spring Bean. Это компоненты специальной инфраструктуры Spring,  выполняющие модификацию компонентов Spring Beans  после их создания. Аннотация **@PostConstruct** регистрируется сред­ствами класса **CommonAnnotationBeanPostProcessor**, и поэтому из данно­го компонента Spring Bean  вызывается метод, снабженный аннотацией **@PostConstruct**. Этот метод выполняется сразу же после построения компонента SpringBean,  но **прежде ввода данного класса в действие**  и до фактической инициализации компонента Spring Bean.